成都麻将


玩法流程：
	基本说法：13 张; 顺数倒摸．

	1.	掷＂骰子＂ 比大小　定＂方位＂
	2.	掷骰子 比大小　定＂庄家＂
	3.	＂洗牌＂，＂码牌＂
	4.	庄家掷骰子 定＂抓牌起点＂
	5	＂买马＂
	6.	轮流＂抓牌＂ 3 次后
	7.	庄家＂跳牌＂
	8.	每人＂补牌＂
	9.	每人设置＂定张＂，或＂报缺＂
	10.	庄家＂打牌＂
	11. "下家" 于摸 1 张牌之后翻开定张（相当于打牌）
	12. 所有人定张已翻开／打出
	13. 依次抓 1 张，打 1 张，直到牌抓光或大部分人已＂胡＂，只剩下一家
	14. ＂查叫＂
	15. ＂结算＂
	16. 跳到第 3 步

注：
	第 5 步　可选，视打牌众人的意愿而定
	第 9, 11, 12 步　可选，视地区规则／打牌众人的意愿而定
	第 10 ~ 13 步， 每个玩家打牌，都有可能发生一些事件：
		摸牌后，摸牌者可以　＂弯杠＂（俗称＂刮风＂），＂暗杠＂（俗称＂下雨＂），＂自摸＂，＂杠上花＂．
		打牌后，别的玩家可以 ＂碰＂，＂直杠＂，＂抢杠＂（胡的一种），＂胡＂；
		打牌者，可能会 ＂引杠＂，＂杠上炮＂，＂点炮＂
		误操作，可能会＂相公＂
	第 14 步　视第 13 步的情况而判断，如果剩余家数不止 1 家，则执行

名词解释：
	骰子：由 2 粒正方体（每面分别标有１～６点）组成，通过滚动后静止来产生两个 1 ~ 6 的随机数．
	方位：东南西北，把桌子看作是中心点，椅子则是指向这 4 个方位的其中一个．
	庄家：第一轮由掷骰子比大小来决定，第二轮起，由第一轮的优先胡牌者，或＂一炮双／三响＂的点炮者担任，先行拿牌（14 张），先行出牌．
	抓牌起点：根据 2 粒骰子产生的数字的总和，由庄家的方位开始，逆时针数数，到所停下的方位，再以顺时针的方向，剩 2 粒骰子点较小的那枚．
	买马：于抓牌起点处所剩下的牌中，参与者抓取 1 ~ n 张牌保存起来（牌局结束之前不可以查看），结算时根据点数从庄家位置开始顺时针数方位，参与者享受该方位同等收益/损失．
	抓牌：刚开始，每人每次抓 2x2 堆叠的牌．打牌阶段，每人每次抓 1 张牌．
	跳牌：庄家于当前摸牌点，再隔 1 墩牌，分别抓取上面一张牌．
	补牌：1. 发生于庄家跳牌之后，非庄家依次抓取一张牌，补够 13 张． 2. 发生于杠牌之后，杠牌玩家从当前摸牌点补抓 1 张．
	定张：将第一张欲打之牌扣起来，待所有人都扣好，轮到时翻开，同时摸入一张，以此来决定该玩家到底是决定缺哪一门花色．
	报缺：向其他玩家声明，自己的原始牌型里，本来就缺一门，具体是哪一门，讲清楚，不需要扣，效果同＂定张＂．如果缺两门，则自行考虑哪门＂报缺＂．
	打牌：从手中的牌中随意拿出一张，花色向上的平放到桌子正中间．
	下家：相对于之前的打牌者，逆时针方向数的下一个方位/玩家．
	查叫：.......
	结算：.....
	碰：.......
	弯杠：.......
	暗杠：.......
	直杠：.......
	引杠：.......
	胡：也叫＂走＂，牌型达到了规则制定的胜利条件........
	自摸：胡的一种，...
	抢杠：胡的一种，...
	杠上炮：胡的一种，...（点炮人的杠钱转过来）
	杠上花：胡的一种，...（引杠人的杠不算钱）
	点炮：胡的一种，...
	三花：.......
	退税：.......
	相公：由误操作引起的牌的张数与胡牌规则永不匹配（例如 碰牌之后去摸了一张再打，或忘记打，杠牌之后忘了摸，直接打了一张之类）

算番：(todo)
	杠（不管是否碰/杠，打散来统计，有 4 张相同 牌） x 2
	青一色 x 4
	带么 x 4
	7对 x 2
	大对子 x 2
	单调 x 2
	杠上花 x 2	(如果是 直杠/引杠，则只赢打牌人, 相当于对方点炮; 弯杠/暗杠后接着便胡牌，赢当时参与打牌的众人)
	自摸 + 1

	直杠 + 2 (只针对打牌人计算)
	弯杠 + 1 (发生之时正在参与打牌的众人)
	暗杠 + 2 (发生之时正在参与打牌的众人)

	算番时，看牌形　以上规则可叠加运算





算法思维：

定义：牌 = 张花点 (张数，花色，点子）


根据规则，通常情况下（特殊的七对等除外），有：
	刻（花点相同：三张），
	顺（花相同，点紧靠：三张），
	对（花点相同：两张），
	单（任意单张）
这几个常见分组规则

判胡条件： （游戏服务只做判胡处理）

	14张：	对 刻 刻 刻 刻
			对 刻 刻 刻 顺
			对 刻 刻 顺 顺
			对 刻 顺 顺 顺
			对 顺 顺 顺 顺
			对 对 对 对 对 对 对	（特殊）

	11张：	对 刻 刻 刻
			对 刻 刻 顺
			对 刻 顺 顺
			对 顺 顺 顺

	8张：	对 刻 刻
			对 刻 顺
			对 顺 顺

	5张：	对 刻
			对 顺

	2张：	对

	同时：成都麻将要求＂缺一门＂，即整副牌只能同时存在２种花色才可胡牌




源数据： 牌[] （最多14张，碰/杠之后会减少）


判胡思路：

需求：
	手牌先按花色分组排序堆叠

前置判断：
非以下的手牌张数胡不了：
	2 5 8 11 14

3 门牌: 
	三花 不胡

2 门牌: 
	其中一门有 1 种花点 且只有 1 张 不胡
	其中一门有 2 种花点 但其中一种是 1 张 不胡

1 门牌:
	有 1 种花点, 不是对子 胡不了, 是对子，　胡
	有 2 种花点 但其中一种是 1 张 不胡

? 门牌:
	没对子, 不胡
	如果牌是 13 张规则，有 7 对, 胡
	...
	如果牌是 7 张规则，有 4 对, 胡	（常见于６人麻将）


1 门牌:
	1. 依次提取出 1对
	2. 将剩下的牌转为 张数组（比如 1wx2, 2wx2, 3wx4, 5wx1 的张数组为   2 2 4 0 1 0 0 0 0　代表了 1 ~ 9 点的牌有多少张）
	3. 从第一张开始判断：
　　		遇 -1 则返回失败
　　		遇 0, 3 则继续判断下一张
　　		遇 1, 4 则令下两张 -1
　　		遇 2 则令下两张 -2
		剩最后两张牌特殊处理：如果非 0 非 3 则返回失败，否则返回　成功（胡牌）
	4. 如果还有对子，跳到 1 ．没有返回失败


2 门牌:　（匹配规则同 1 门牌）
	统计2门的对子数
	如果: 1 有对, 2 无对, 但 1 剩下的牌 无法匹配, 胡不了
	如果: 2 有对, 1 无对, 但 2 剩下的牌 无法匹配, 胡不了
	如果: 1, 2 均有对, 
		则: 首先看 1, 2 分别在拿掉对子之后能否匹配. 
		如果 1 在拿掉对子之后无法匹配, 则继续判断:
			 2 在拿掉对子之后匹配, 1 则不用拿对子, 如果匹配则 胡了 不匹配则 不胡
		如果 1 在拿掉对子之后匹配, 2 则不用拿对子, 如果匹配则 胡了 不匹配则 不胡










思路1：
	根据上面的规则，首先判断是否只有两种花色，
	再看手牌总张数，然后排序，
	最后根据每种组合，开始匹配，完全匹配成功　则认为胡了
	具体匹配过程为：
		尝试从手牌中提取出任意１对，然后再用（刻，顺）匹配剩下的牌，实现完全匹配一张不剩即吃胡


做法所用到的基本元素：

牌[]   ps　	玩家的牌，所有牌为１张，带状态，有重复（花点）
牌[][] gps　	堆叠牌，按状态分组排序，无重复（花点），堆叠张数
牌[]   cps　	堆叠牌之一组（单一状态，已排序已堆叠）

// 参数：玩家的牌
// 返回：状态分组堆叠牌（状态顺序：手牌, 碰牌, 杠牌）
牌[][] 堆叠分组排序（牌[] ps）

// 参数：堆叠牌之一组（已排序），堆叠牌之一组（已排序），cps2 于 cps1 的起始位置
// 返回：两组牌相减后的结果（维持排序）
牌[] 减去（牌[] cps1, 牌[] cps2, int index）

// 参数：一组牌
// 返回：一组牌的复制体
牌[] 复制（牌[] ps）





具体做法1：


1. 首先按　花,点 排序　并保存
2. 判断花色是否只有２种
3. 递归开始：
3.10 准备结果分组容器：（按张数，判胡条件来，完型填空的效果，再加上剩牌容器）
	（根据分析发现，判胡条件至少须满足　有１对，所以）
3.2 判断特殊牌型：７对（扫　牌的所有＂张＂是否为偶数即可），满足则返回 胡   --将组合写入结果容器
3.3	扫剩牌，得到所有　对的可能，并从已排序　牌[] 中减去这个 对，纳入　组合[]
			对　组合[]　排序（对 刻 顺），将引用存入分组的结果容器（同时判断是否重复，重复则跳出）
			如果牌还有剩，跳至 3.4
3.4		扫剩牌，得到所有　刻的可能，并从已排序　牌[] 中减去这个 刻，纳入　组合[]
3.5		扫剩牌，得到所有　顺的可能，并从已排序　牌[] 中减去这个 顺，纳入　组合[]
			对　组合[]　排序（对 刻 顺），将引用存入分组的结果容器（同时判断是否重复，重复则跳出）
			如果牌还有剩，跳至 3.4
3.6	无剩牌, 返回 胡

重点: 分组存放按规则排列组合的结果, 及时判断组合是否已存在



扫描方式（基于单状态已排序堆叠牌组）：
	n = 1
	从第 n 张开始判断：
		如果 ps[n].张 >= 3
				则认为该处有 刻， 计算剩牌
					sps = 减去(ps, new 牌[] { 
						new 牌{张 = 3, 花点 = ps[n].花点 }
					}, n) 并继续扫剩牌
		如果 n <= ps.Length - 2 且
		     ps[n].花 == ps[n+1].花  且
			 ps[n].花 == ps[n+2].花  且
			 ps[n].点+1 == ps[n+1].点  且
			 ps[n].点+2 == ps[n+2].点  且
				则认为该处有 顺， 计算剩牌
					sps = 减去(ps, new 牌[] {
						new 牌{ 张 = 1, 花点 = ps[n].花点 },
						new 牌{ 张 = 1, 花点 = ps[n].花点+1 },
						new 牌{ 张 = 1, 花点 = ps[n].花点+2 }
					}, n) 并继续扫剩牌
	n++
扫对子的情况类似上面．（在外面套）
优化：可以将 ps[n] 先行取出， Length, Length - 2 也于循环前计算




结果容器： 
匹配项 = 规则 + 牌[]
中间结果 = List<匹配项> + 剩牌[]
根据 判胡条件的 15 个组合，　将中间结果分类存入　以方便对比：

Results_2_1
Results_5_1
Results_5_2
Results_8_1
Results_8_2
Results_8_3
...




算番规则：

算番条件：

思路：在上面判胡思路基础上，将所有可胡的牌型，记录下来，最后看有哪几种胡法，再取每一种胡法对应的所有的番数，最后看哪一种胡法番最高
















思路调整:

经检测, 数组在创建,访问,复制方面较 List 有极大优势 (主要是慢在 resize 方面), 故:
考虑这样设计具体编码方式:
首先预估一下, 整个递归会产生多少个结果集, 每个结果的最大长度, 以内存缓冲区形式来提速:
创建两个大数组

假设: 不重复的结果集 最多 5000 个, 成功凑成的 坎数 最多 7 个(至少是个对子), 剩牌最多 14 张

坎牌[5000,7]
坎牌长度[5000]
剩牌[5000,14]
剩牌长度[5000]
i = 0

设置一个索引, 指向这两个数组  即: 每递归步骤产生的结果, 均存入 坎牌[i] , 剩牌[i]  , i++
如果发现 该结果(扫描数组中已存在的数据) 重复, 认为属于重复的计算, i 不变, 留待下次计算覆盖当前使用的数组内容

坎牌[] 的内容直接以 牌 的结构(张数部分放置类型信息) 构成坎的唯一编码,  即每个元素都代表一坎牌.

















