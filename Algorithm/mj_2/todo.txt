成都麻将　算法思维：

定义：牌 = 张花点 (张数，花色，点子）

源数据： 牌[] （最多14张，碰/杠之后会减少）

根据规则，通常情况下（特殊的七对等除外），有：
	刻（花点相同：三张），
	顺（花相同，点紧靠：三张），
	对（花点相同：两张），
	单（任意单张）
这几个常见分组规则

判胡条件： （游戏服务只做判胡处理）

	14张：	对 刻 刻 刻 刻
			对 刻 刻 刻 顺
			对 刻 刻 顺 顺
			对 刻 顺 顺 顺
			对 顺 顺 顺 顺
			对 对 对 对 对 对 对

	11张：	对 刻 刻 刻
			对 刻 刻 顺
			对 刻 顺 顺
			对 顺 顺 顺

	8张：	对 刻 刻
			对 刻 顺
			对 顺 顺

	5张：	对 刻
			对 顺

	2张：	对

	同时：成都麻将要求＂缺一门＂，即整副牌只能同时存在２种花色才可胡牌

1 2 3 4	7 8 9 a
  2 3     8   a
          8   a


思路1：
	根据上面的规则，首先判断是否只有两种花色，
	再看手牌总张数，然后排序，
	最后根据每种组合，开始匹配，完全匹配成功　则认为胡了
	具体匹配过程为：
		尝试从手牌中提取出任意１对，然后再用（刻，顺）匹配剩下的牌，实现完全匹配一张不剩即吃胡


做法所用到的基本元素：

牌[]   ps　	玩家的牌，所有牌为１张，带状态，有重复（花点）
牌[][] gps　	堆叠牌，按状态分组排序，无重复（花点），堆叠张数
牌[]   cps　	堆叠牌之一组（单一状态，已排序已堆叠）

// 参数：玩家的牌
// 返回：状态分组堆叠牌（状态顺序：手牌, 碰牌, 杠牌）
牌[][] 堆叠分组排序（牌[] ps）

// 参数：堆叠牌之一组（已排序），堆叠牌之一组（已排序），cps2 于 cps1 的起始位置
// 返回：两组牌相减后的结果（维持排序）
牌[] 减去（牌[] cps1, 牌[] cps2, int index）

// 参数：一组牌
// 返回：一组牌的复制体
牌[] 复制（牌[] ps）





具体做法1：


1. 首先按　花,点 排序　并保存
2. 判断花色是否只有２种
3. 递归开始：
3.10 准备结果分组容器：（按张数，判胡条件来，完型填空的效果，再加上剩牌容器）
	（根据分析发现，判胡条件至少须满足　有１对，所以）
3.2 判断特殊牌型：７对（扫　牌的所有＂张＂是否为偶数即可），满足则返回 胡   --将组合写入结果容器
3.3	扫剩牌，得到所有　对的可能，并从已排序　牌[] 中减去这个 对，纳入　组合[]
			对　组合[]　排序（对 刻 顺），将引用存入分组的结果容器（同时判断是否重复，重复则跳出）
			如果牌还有剩，跳至 3.4
3.4		扫剩牌，得到所有　刻的可能，并从已排序　牌[] 中减去这个 刻，纳入　组合[]
3.5		扫剩牌，得到所有　顺的可能，并从已排序　牌[] 中减去这个 顺，纳入　组合[]
			对　组合[]　排序（对 刻 顺），将引用存入分组的结果容器（同时判断是否重复，重复则跳出）
			如果牌还有剩，跳至 3.4
3.6	无剩牌, 返回 胡

重点: 分组存放按规则排列组合的结果, 及时判断组合是否已存在



扫描方式（基于单状态已排序堆叠牌组）：
	n = 1
	从第 n 张开始判断：
		如果 ps[n].张 >= 3 则认为该处有 刻， 得到剩牌
				sps = 减去(ps, new 牌[] { 
						new 牌{张 = 3, 花点 = ps[n].花点 }
					}, n) 并继续扫剩牌
		如果 n <= ps.Length - 2 且
		     ps[n].花 == ps[n+1].花  且
			 ps[n].花 == ps[n+2].花  且
			 ps[n].点+1 == ps[n+1].点  且
			 ps[n].点+2 == ps[n+2].点  且
				则认为该处有 顺，， 得到剩牌
				sps = 减去(ps, new 牌[] {
						new 牌{ 张 = 1, 花点 = ps[n].花点 },
						new 牌{ 张 = 1, 花点 = ps[n].花点+1 },
						new 牌{ 张 = 1, 花点 = ps[n].花点+2 }
					}, n) 并继续扫剩牌
	n++





算番规则：

算番条件：

思路：在上面判胡思路基础上，将所有可胡的牌型，记录下来，最后看有哪几种胡法，再取每一种胡法对应的所有的番数，最后看哪一种胡法番最高

