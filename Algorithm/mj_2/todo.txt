成都麻将　算法思维：

定义：牌 = 张花点 (张数，花色，点子）

源数据： 牌[] （最多14张，碰/杠之后会减少）

根据规则，通常情况下（特殊的七对等除外），有：
	刻（花点相同：三张），
	顺（花相同，点紧靠：三张），
	对（花点相同：两张），
	单（任意单张）
这几个常见分组规则

判胡条件： （游戏服务只做判胡处理）

	14张：	对 刻 刻 刻 刻
			对 刻 刻 刻 顺
			对 刻 刻 顺 顺
			对 刻 顺 顺 顺
			对 顺 顺 顺 顺
			对 对 对 对 对 对 对	（特殊）

	11张：	对 刻 刻 刻
			对 刻 刻 顺
			对 刻 顺 顺
			对 顺 顺 顺

	8张：	对 刻 刻
			对 刻 顺
			对 顺 顺

	5张：	对 刻
			对 顺

	2张：	对

	同时：成都麻将要求＂缺一门＂，即整副牌只能同时存在２种花色才可胡牌

1 2 3 4	7 8 9 a
  2 3     8   a
          8   a


思路1：
	根据上面的规则，首先判断是否只有两种花色，
	再看手牌总张数，然后排序，
	最后根据每种组合，开始匹配，完全匹配成功　则认为胡了
	具体匹配过程为：
		尝试从手牌中提取出任意１对，然后再用（刻，顺）匹配剩下的牌，实现完全匹配一张不剩即吃胡


做法所用到的基本元素：

牌[]   ps　	玩家的牌，所有牌为１张，带状态，有重复（花点）
牌[][] gps　	堆叠牌，按状态分组排序，无重复（花点），堆叠张数
牌[]   cps　	堆叠牌之一组（单一状态，已排序已堆叠）

// 参数：玩家的牌
// 返回：状态分组堆叠牌（状态顺序：手牌, 碰牌, 杠牌）
牌[][] 堆叠分组排序（牌[] ps）

// 参数：堆叠牌之一组（已排序），堆叠牌之一组（已排序），cps2 于 cps1 的起始位置
// 返回：两组牌相减后的结果（维持排序）
牌[] 减去（牌[] cps1, 牌[] cps2, int index）

// 参数：一组牌
// 返回：一组牌的复制体
牌[] 复制（牌[] ps）





具体做法1：


1. 首先按　花,点 排序　并保存
2. 判断花色是否只有２种
3. 递归开始：
3.10 准备结果分组容器：（按张数，判胡条件来，完型填空的效果，再加上剩牌容器）
	（根据分析发现，判胡条件至少须满足　有１对，所以）
3.2 判断特殊牌型：７对（扫　牌的所有＂张＂是否为偶数即可），满足则返回 胡   --将组合写入结果容器
3.3	扫剩牌，得到所有　对的可能，并从已排序　牌[] 中减去这个 对，纳入　组合[]
			对　组合[]　排序（对 刻 顺），将引用存入分组的结果容器（同时判断是否重复，重复则跳出）
			如果牌还有剩，跳至 3.4
3.4		扫剩牌，得到所有　刻的可能，并从已排序　牌[] 中减去这个 刻，纳入　组合[]
3.5		扫剩牌，得到所有　顺的可能，并从已排序　牌[] 中减去这个 顺，纳入　组合[]
			对　组合[]　排序（对 刻 顺），将引用存入分组的结果容器（同时判断是否重复，重复则跳出）
			如果牌还有剩，跳至 3.4
3.6	无剩牌, 返回 胡

重点: 分组存放按规则排列组合的结果, 及时判断组合是否已存在



扫描方式（基于单状态已排序堆叠牌组）：
	n = 1
	从第 n 张开始判断：
		如果 ps[n].张 >= 3
				则认为该处有 刻， 计算剩牌
					sps = 减去(ps, new 牌[] { 
						new 牌{张 = 3, 花点 = ps[n].花点 }
					}, n) 并继续扫剩牌
		如果 n <= ps.Length - 2 且
		     ps[n].花 == ps[n+1].花  且
			 ps[n].花 == ps[n+2].花  且
			 ps[n].点+1 == ps[n+1].点  且
			 ps[n].点+2 == ps[n+2].点  且
				则认为该处有 顺， 计算剩牌
					sps = 减去(ps, new 牌[] {
						new 牌{ 张 = 1, 花点 = ps[n].花点 },
						new 牌{ 张 = 1, 花点 = ps[n].花点+1 },
						new 牌{ 张 = 1, 花点 = ps[n].花点+2 }
					}, n) 并继续扫剩牌
	n++
扫对子的情况类似上面．（在外面套）
优化：可以将 ps[n] 先行取出， Length, Length - 2 也于循环前计算




结果容器： 
匹配项 = 规则 + 牌[]
中间结果 = List<匹配项> + 剩牌[]
根据 判胡条件的 15 个组合，　将中间结果分类存入　以方便对比：

Results_2_1
Results_5_1
Results_5_2
Results_8_1
Results_8_2
Results_8_3
...




算番规则：

算番条件：

思路：在上面判胡思路基础上，将所有可胡的牌型，记录下来，最后看有哪几种胡法，再取每一种胡法对应的所有的番数，最后看哪一种胡法番最高
















思路调整:

经检测, 数组在创建,访问,复制方面较 List 有极大优势 (主要是慢在 resize 方面), 故:
考虑这样设计具体编码方式:
首先预估一下, 整个递归会产生多少个结果集, 每个结果的最大长度, 以内存缓冲区形式来提速:
创建两个大数组

假设: 不重复的结果集 最多 5000 个, 成功凑成的 坎数 最多 7 个(至少是个对子), 剩牌最多 14 张

坎牌[5000,7]
坎牌长度[5000]
剩牌[5000,14]
剩牌长度[5000]
i = 0

设置一个索引, 指向这两个数组  即: 每递归步骤产生的结果, 均存入 坎牌[i] , 剩牌[i]  , i++
如果发现 该结果(扫描数组中已存在的数据) 重复, 认为属于重复的计算, i 不变, 留待下次计算覆盖当前使用的数组内容

坎牌[] 的内容直接以 牌 的结构(张数部分放置类型信息) 构成坎的唯一编码,  即每个元素都代表一坎牌.

