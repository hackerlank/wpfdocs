成都麻将


玩法流程：
	基本说法：13 张; 顺数倒摸．
	玩家进场后，
	1.	掷＂骰子＂ 比大小　定＂方位＂
	2.	掷骰子 比大小　定＂庄家＂
	3.	＂洗牌＂，＂码牌＂
	4.	庄家掷骰子 定＂抓牌起点＂
	5	＂买马＂
	6.	轮流＂抓牌＂ 3 次后
	7.	庄家＂跳牌＂
	8.	每人＂补牌＂
	9.	每人设置＂定张＂，或＂报缺＂
	10.	庄家＂打牌＂
	11. "下家" 于摸 1 张牌之后翻开定张（相当于打牌）
	12. 所有人定张已翻开／打出
	13. 依次抓 1 张，打 1 张，＂一轮＂一轮的打，直到牌抓光 或 大部分人已＂胡＂，只剩下一家
	14. ＂查叫＂
	15. ＂结算＂
	16. 跳到第 3 步

注：
	第 5 步　可选，视打牌众人的意愿而定
	第 9, 11, 12 步　可选，视地区规则／打牌众人的意愿而定
	第 10 ~ 13 步， 每个玩家打牌，都有可能发生一些事件：
		摸牌后，摸牌者可以　＂弯杠＂（俗称＂刮风＂），＂直杠＂（俗称＂暗杠＂，＂下雨＂），＂自摸＂，＂杠上花＂．
		打牌后，别的玩家可以 ＂碰＂，＂引杠＂，＂抢杠＂（胡的一种），＂胡＂；
		打牌者，可能会 ＂杠上炮＂，＂点炮＂
		误操作，可能会＂相公＂
	第 14 步　视第 13 步的情况而判断，如果剩余家数不止 1 家，则执行

潜规则：
	1. 假设有 abcd 玩家依次出牌，一轮之内，a 出了 1 张牌，是 d 可以胡的，但 d 决定不胡，之后轮到 b/c , 也打这张牌， 
		规则明确指出，此时　d 就算想胡也不可以，本轮只能胡别人打出的其他牌，或自摸刚才那张．
	

名词解释：
	骰子：由 2 粒正方体（每面分别标有１～６点）组成，通过滚动后静止来产生两个 1 ~ 6 的随机数．
	方位：东南西北，把桌子看作是中心点，椅子则是指向这 4 个方位的其中一个．
	庄家：第一轮由掷骰子比大小来决定，第二轮起，由第一轮的优先胡牌者，或＂一炮双／三响＂的点炮者担任，先行拿牌（14 张），先行出牌．
	抓牌起点：根据 2 粒骰子产生的数字的总和，由庄家的方位开始，逆时针数数，到所停下的方位，再以顺时针的方向，剩 2 粒骰子点较小的那枚．
	买马：于抓牌起点处所剩下的牌中，参与者抓取 1 ~ n 张牌保存起来（牌局结束之前不可以查看），结算时根据点数从庄家位置开始顺时针数方位，参与者享受该方位同等收益/损失．
	抓牌：刚开始，每人每次抓 2x2 堆叠的牌．打牌阶段，每人每次抓 1 张牌．
	跳牌：庄家于当前摸牌点，再隔 1 墩牌，分别抓取上面一张牌．
	补牌：1. 发生于庄家跳牌之后，非庄家依次抓取一张牌，补够 13 张． 2. 发生于杠牌之后，杠牌玩家从当前摸牌点补抓 1 张．
	定张：将第一张欲打之牌扣起来，待所有人都扣好，轮到时翻开，同时摸入一张，以此来决定该玩家到底是决定缺哪一门花色．
	报缺：向其他玩家声明，自己的原始牌型里，本来就缺一门，具体是哪一门，讲清楚，不需要扣，效果同＂定张＂．如果缺两门，则自行考虑哪门＂报缺＂．
	打牌：从手中的牌中随意拿出一张，花色向上的平放到桌子正中间．
	下家：相对于之前的打牌者，逆时针方向数的下一个方位/玩家．
	一轮：4 个玩家依次摸牌并打出，即一个打牌的循环周期．
	查叫：牌已抓光，依然有 2 家以上玩家在参与，则须看每个玩家的牌型，是否有＂叫＂，没有叫的玩家被认为是点了参与查叫的有叫玩家的炮而判输．
	结算：整理统计当次牌局的刮风/下雨/胡牌/查叫/买马数据，并对相应玩家作出赏罚处理．
	手牌：玩家手上的（不包括拿下来放到一边的堆叠牌），可用于匹配胡牌规则任意组合的牌张，包括刚摸到的牌．
	碰：玩家＂手牌＂中有两张相同的牌，当别的玩家打出此牌时，该玩家可以叫碰，用手中的这 2 张加上别人打出的那张，堆叠到自己手牌附近．
	弯杠：在有碰（手牌附近已存在 3 张堆叠）的基础之上，自己从手牌中再拿出一张相同的放入堆叠．
	直杠：玩家直接从手牌中一次性拿出 4 张相同的牌，形成堆叠放在手牌旁边．
	引杠：玩家手牌中有 3 张相同的牌，当别的玩家打出此牌时，该玩家可以叫杠，用手中的这 3 张加上别人打出的那张，堆叠到自己手牌附近．
	叫：在没模牌的情况下，只差 1 张牌即可达成规则制定的胜利条件的牌型．
	胡：也叫＂走＂，手牌或手牌加上别人打出的牌，牌型达到了规则制定的胜利条件．
	自摸：胡的一种，在自己摸牌之后，牌未打出之前，宣告胡牌（剩下的未走掉的玩家均要付出代价）．
	点炮：胡的一种，胡别人打出来的牌均叫点炮（打出那张牌的玩家要付出代价）．
	抢杠：胡的一种，当别的玩家正在做弯杠时，拦截并胡牌（算点炮）．
	杠上炮：胡的一种，玩家经过杠，摸，打之后立即点炮．
	杠上花：胡的一种，玩家经过杠，摸之后立即胡牌（引杠算点炮，弯杠/直杠算自摸）．
	三花：查叫阶段玩家被发现三种花色均存在，则该玩家要受到相当于是 查叫阶段 点炮 所有 查叫时 有叫玩家 额外的 8/16 番牌的惩罚．
	退税：查叫阶段，有杠玩家被发现无＂叫＂，该杠的效果作废．
	诈胡：玩家谎称／误判自己已胡牌，被查出后，则该玩家要受到相当于是 点炮 所有人 8/16 番牌的惩罚．
	相公：由误操作引起的牌的张数与胡牌规则永不匹配（例如 碰牌之后去摸了一张再打，或忘记打，杠牌之后忘了摸，直接打了一张之类）

算番牌型：
	前提：三花直接算点所有人的炮．
	吃胡牌型有以下要素：
		根：不管是否碰/杠，所有牌打散来统计，每出现 4 张相同 牌计 1 根．
		青一色：所有杠牌／手牌全属于同一种花色．
		带么：由顺子（123 或 789），刻子（111, 999），对子（11, 99）组成的牌．
		7 对：没有碰杠，胡牌时牌型由 7 个对子组成．
		大对子：可碰杠，胡牌时牌型由两种组合构成： 1 个对子 + 数个 刻子．
		大吊车：碰杠到只剩一张牌之后胡牌．
		杠上花：杠牌之后补上来的牌吃胡．
		自摸：轮到自己抓牌时，抓起来即吃胡．
	另： 7 对 + 根　也叫　龙 7 对．

打牌过程中产生的额外收入对照表：
	弯杠：最后 + 1（同自摸覆盖面）
	直杠：最后 + 2（同自摸覆盖面）
	引杠：最后 + 2（同点炮覆盖面）

牌型/番　对照表：
	根：x 2^根数
	青一色：x 4
	带么：x 4
	7 对：x 4
	大对子：x 2
	大吊车：x 2
	杠上花：x 2
	自摸：最后 + 1

胡牌牌型中，凡是能对应上面的　算番牌型的，累计运算出结果．




算法思维：

定义：牌 = 张花点 (张数，花色，点子）


根据规则，通常情况下（特殊的七对等除外），有：
	刻（花点相同：三张），
	顺（花相同，点紧靠：三张），
	对（花点相同：两张），
	单（任意单张）
这几个常见分组规则

判胡条件： （游戏服务只做判胡处理）

	14张：	对 刻 刻 刻 刻
			对 刻 刻 刻 顺
			对 刻 刻 顺 顺
			对 刻 顺 顺 顺
			对 顺 顺 顺 顺
			对 对 对 对 对 对 对	（特殊）

	11张：	对 刻 刻 刻
			对 刻 刻 顺
			对 刻 顺 顺
			对 顺 顺 顺

	8张：	对 刻 刻
			对 刻 顺
			对 顺 顺

	5张：	对 刻
			对 顺

	2张：	对

	同时：成都麻将要求＂缺一门＂，即整副牌只能同时存在２种花色才可胡牌




源数据： 牌[] （最多14张，碰/杠之后会减少）


判胡思路：

需求：
	手牌先按花色分组排序堆叠

前置判断：
非以下的手牌张数胡不了：
	2 5 8 11 14

3 门牌: 
	三花 不胡

2 门牌: 
	其中一门有 1 种花点 且只有 1 张 不胡
	其中一门有 2 种花点 但其中一种是 1 张 不胡

1 门牌:
	有 1 种花点, 不是对子 胡不了, 是对子，　胡
	有 2 种花点 但其中一种是 1 张 不胡

? 门牌:
	没对子, 不胡
	如果牌是 13 张规则，有 7 对, 胡
	...
	如果牌是 7 张规则，有 4 对, 胡	（常见于６人麻将）


1 门牌:
	1. 依次提取出 1对
	2. 将剩下的牌转为 张数组（比如 1wx2, 2wx2, 3wx4, 5wx1 的张数组为   2 2 4 0 1 0 0 0 0　代表了 1 ~ 9 点的牌有多少张）
	3. 从第一张开始判断：
　　		遇 -1 则返回失败
　　		遇 0, 3 则继续判断下一张
　　		遇 1, 4 则令下两张 -1
　　		遇 2 则令下两张 -2
		剩最后两张牌特殊处理：如果非 0 非 3 则返回失败，否则返回　成功（胡牌）
	4. 如果还有对子，跳到 1 ．没有返回失败


2 门牌:　（匹配规则同 1 门牌）
	统计2门的对子数
	如果: 1 有对, 2 无对, 但 1 剩下的牌 无法匹配, 胡不了
	如果: 2 有对, 1 无对, 但 2 剩下的牌 无法匹配, 胡不了
	如果: 1, 2 均有对, 
		则: 首先看 1, 2 分别在拿掉对子之后能否匹配. 
		如果 1 在拿掉对子之后无法匹配, 则继续判断:
			 2 在拿掉对子之后匹配, 1 则不用拿对子, 如果匹配则 胡了 不匹配则 不胡
		如果 1 在拿掉对子之后匹配, 2 则不用拿对子, 如果匹配则 胡了 不匹配则 不胡










思路1：
	根据上面的规则，首先判断是否只有两种花色，
	再看手牌总张数，然后排序，
	最后根据每种组合，开始匹配，完全匹配成功　则认为胡了
	具体匹配过程为：
		尝试从手牌中提取出任意１对，然后再用（刻，顺）匹配剩下的牌，实现完全匹配一张不剩即吃胡


做法所用到的基本元素：

牌[]   ps　	玩家的牌，所有牌为１张，带状态，有重复（花点）
牌[][] gps　	堆叠牌，按状态分组排序，无重复（花点），堆叠张数
牌[]   cps　	堆叠牌之一组（单一状态，已排序已堆叠）

// 参数：玩家的牌
// 返回：状态分组堆叠牌（状态顺序：手牌, 碰牌, 杠牌）
牌[][] 堆叠分组排序（牌[] ps）

// 参数：堆叠牌之一组（已排序），堆叠牌之一组（已排序），cps2 于 cps1 的起始位置
// 返回：两组牌相减后的结果（维持排序）
牌[] 减去（牌[] cps1, 牌[] cps2, int index）

// 参数：一组牌
// 返回：一组牌的复制体
牌[] 复制（牌[] ps）





具体做法1：


1. 首先按　花,点 排序　并保存
2. 判断花色是否只有２种
3. 递归开始：
3.10 准备结果分组容器：（按张数，判胡条件来，完型填空的效果，再加上剩牌容器）
	（根据分析发现，判胡条件至少须满足　有１对，所以）
3.2 判断特殊牌型：７对（扫　牌的所有＂张＂是否为偶数即可），满足则返回 胡   --将组合写入结果容器
3.3	扫剩牌，得到所有　对的可能，并从已排序　牌[] 中减去这个 对，纳入　组合[]
			对　组合[]　排序（对 刻 顺），将引用存入分组的结果容器（同时判断是否重复，重复则跳出）
			如果牌还有剩，跳至 3.4
3.4		扫剩牌，得到所有　刻的可能，并从已排序　牌[] 中减去这个 刻，纳入　组合[]
3.5		扫剩牌，得到所有　顺的可能，并从已排序　牌[] 中减去这个 顺，纳入　组合[]
			对　组合[]　排序（对 刻 顺），将引用存入分组的结果容器（同时判断是否重复，重复则跳出）
			如果牌还有剩，跳至 3.4
3.6	无剩牌, 返回 胡

重点: 分组存放按规则排列组合的结果, 及时判断组合是否已存在



扫描方式（基于单状态已排序堆叠牌组）：
	n = 1
	从第 n 张开始判断：
		如果 ps[n].张 >= 3
				则认为该处有 刻， 计算剩牌
					sps = 减去(ps, new 牌[] { 
						new 牌{张 = 3, 花点 = ps[n].花点 }
					}, n) 并继续扫剩牌
		如果 n <= ps.Length - 2 且
		     ps[n].花 == ps[n+1].花  且
			 ps[n].花 == ps[n+2].花  且
			 ps[n].点+1 == ps[n+1].点  且
			 ps[n].点+2 == ps[n+2].点  且
				则认为该处有 顺， 计算剩牌
					sps = 减去(ps, new 牌[] {
						new 牌{ 张 = 1, 花点 = ps[n].花点 },
						new 牌{ 张 = 1, 花点 = ps[n].花点+1 },
						new 牌{ 张 = 1, 花点 = ps[n].花点+2 }
					}, n) 并继续扫剩牌
	n++
扫对子的情况类似上面．（在外面套）
优化：可以将 ps[n] 先行取出， Length, Length - 2 也于循环前计算




结果容器： 
匹配项 = 规则 + 牌[]
中间结果 = List<匹配项> + 剩牌[]
根据 判胡条件的 15 个组合，　将中间结果分类存入　以方便对比：

Results_2_1
Results_5_1
Results_5_2
Results_8_1
Results_8_2
Results_8_3
...




算番规则：

算番条件：

思路：在上面判胡思路基础上，将所有可胡的牌型，记录下来，最后看有哪几种胡法，再取每一种胡法对应的所有的番数，最后看哪一种胡法番最高
















思路调整:

经检测, 数组在创建,访问,复制方面较 List 有极大优势 (主要是慢在 resize 方面), 故:
考虑这样设计具体编码方式:
首先预估一下, 整个递归会产生多少个结果集, 每个结果的最大长度, 以内存缓冲区形式来提速:
创建两个大数组

假设: 不重复的结果集 最多 5000 个, 成功凑成的 坎数 最多 7 个(至少是个对子), 剩牌最多 14 张

坎牌[5000,7]
坎牌长度[5000]
剩牌[5000,14]
剩牌长度[5000]
i = 0

设置一个索引, 指向这两个数组  即: 每递归步骤产生的结果, 均存入 坎牌[i] , 剩牌[i]  , i++
如果发现 该结果(扫描数组中已存在的数据) 重复, 认为属于重复的计算, i 不变, 留待下次计算覆盖当前使用的数组内容

坎牌[] 的内容直接以 牌 的结构(张数部分放置类型信息) 构成坎的唯一编码,  即每个元素都代表一坎牌.

















